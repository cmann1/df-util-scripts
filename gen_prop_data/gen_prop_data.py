import json
import pprint

prop_groups = ['books', 'buildingblocks', 'chains', 'decoration', 'facade', 'foliage', 'furniture', 'gazebo',
               'lighting', '', 'statues', 'storage', 'study', 'fencing', '', '',
               '', '', 'backleaves', 'leaves', 'trunks', 'boulders', 'backdrops', 'temple',
               'npc', 'symbol', 'cars', 'sidewalk', 'machinery']

with open('../_common/sprite-data.json', 'rb') as f:
	prop_data = json.load(f)

output = [[] for _ in range(29)]
indices_output_data = [[] for _ in range(29)]
indices_output_dict = []

for set_index in prop_data:
	set_data = prop_data[set_index]
	
	for group_index in set_data:
		output_group = output[int(group_index)]
		indices_group = indices_output_data[int(group_index)]
		group_data = set_data[group_index]
		group_name = group_data['name']
		group_sprites = group_data['sprites']
		
		for sprite_index in group_sprites:
			sprite_data = group_sprites[sprite_index]
			x, y, w, h = sprite_data['bounds']
			rect_x, rect_y, rect_w, rect_h = sprite_data['palettes'][0][0]['rect']
			_, _, rect_uw, rect_uh = sprite_data['palettes'][0][0]['rect_uv']
			
			ox, oy = sprite_data['origin'] if 'origin' in sprite_data else (0.5, 0.5)
			ox = (ox * rect_w) / w
			oy = (oy * rect_h) / h
			
			x += rect_x
			y += rect_y
			
			palette_count = sprite_data['palette_count']
			name = sprite_data['name_nice']
			
			sprite_array_index = len(indices_group)
			key = f'{set_index}.{group_index}.{sprite_index}'
			indices_output_dict.append(f"\t{{'{key}', {sprite_array_index}}}")
			
			indices_group.append(f'\t\tPropIndex({set_index}, {group_index}, {sprite_index}, {palette_count}, "{name}", {sprite_array_index}),\n')
			output_group.append(f'\t\tPropBounds({x}, {y}, {w}, {h}, {ox}, {oy}),\n')

		# pprint.pprint(output)

#
# Generate indices data
# ---------------------------------------------------

WARNING = '/* Auto generated by .scripts/gen_prop_data.py. Do not edit. */\n\n'

indices_output_class = '''#include 'common.cpp';

class PropIndex
{
	
	uint set;
	uint group;
	uint index;
	uint palettes;
	uint array_index;
	string name;
	
	PropIndex() { }
	
	PropIndex(uint set, uint group, uint index, uint palettes, string name, uint array_index)
	{
		this.set = set;
		this.group = group;
		this.index = index;
		this.palettes = palettes;
		this.name = name;
		this.array_index = array_index;
	}
	
	string sprite_set_name() const
	{
		return 'props' + set;
	}
	
	string sprite_name() const
	{
		return PROP_GROUP_NAMES[group] + '_' + index;
	}
	
}

/** Takes the prop index and returns an index in PROP_INDICES  */
int prop_index_to_array_index(uint prop_set, uint prop_group, uint prop_index)
{
	string key = prop_set + '.' + prop_group + '.' + prop_index;
	
	if(PROP_INDEX_MAP.exists(key))
	{
		return int(PROP_INDEX_MAP[key]);
	}
	
	return -1;
}

'''
indices_output_list = '''/** Each item corresponds to a group defined in props.PROP_GROUP_NAMES */
const array<array<PropIndex>> PROP_INDICES = {
'''
indices_output_map = '''/** Takes the prop index and returns an index in PROP_INDICES  */
const dictionary PROP_INDEX_MAP = {
'''

for i in range(len(indices_output_data)):
	indices_group = indices_output_data[i]
	
	if len(indices_group) == 0:
		indices_output_list += '\t{},\n'
		continue
	
	indices_group_str = ''.join(indices_group)
	group_name = prop_groups[i]
	
	indices_output_list += f'\t{{ // {group_name}\n{indices_group_str}\t}},\n'

indices_output_list += '};\n\n'
indices_output_map += ',\n'.join(indices_output_dict) + '\n};'

with open('../props/data.cpp', 'w') as f:
	f.write(WARNING + indices_output_class + indices_output_list + indices_output_map)

#
# Generate bounds data
# ---------------------------------------------------

bounds_output = WARNING + '''class PropBounds
{

	float x;
	float y;
	float width;
	float height;
	float origin_x;
	float origin_y;

	PropBounds() { }

	PropBounds(float x, float y, float width, float height, float origin_x, float origin_y)
	{
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		this.origin_x = origin_x;
		this.origin_y = origin_y;
	}

}

// Each item corresponds to a group defined in props.PROP_GROUP_NAMES
const array<array<PropBounds>> PROP_BOUNDS = {
'''

for i in range(len(output)):
	bounds_group = output[i]

	if len(bounds_group) == 0:
		bounds_output += '\t{},\n'
		continue

	bounds_group_str = ''.join(bounds_group)
	group_name = prop_groups[i]

	bounds_output += f'\t{{ // {group_name}\n{bounds_group_str}\t}},\n'

bounds_output += '};'

with open('../props/bounds_data.cpp', 'w') as f:
	f.write(bounds_output)
